# -*- coding: utf-8 -*-
"""TH2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OxE0vqfeymav1ytyiXD2waYSoXKcG_Bk
"""

import pandas as pd
import numpy as np
from hmmlearn.hmm import GaussianHMM
from pykalman import KalmanFilter
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error, accuracy_score

# Đọc dữ liệu
df = pd.read_csv("slds_data.csv")

# Dữ liệu vận tốc dùng cho HMM
velocity_data = df[['VX', 'VY']].values
true_position = df[['X_Position', 'Y_Position']].values
true_modes = df['Mode'].values if 'Mode' in df.columns else None

# Huấn luyện HMM để tìm chế độ rời rạc
n_components = 2
hmm = GaussianHMM(n_components=n_components, covariance_type="full", n_iter=100, random_state=42)
hmm.fit(velocity_data)
predicted_modes = hmm.predict(velocity_data)

print("🔁 Ma trận chuyển trạng thái giữa các chế độ (A):")
print(hmm.transmat_)

print("\n🎯 Xác suất ban đầu của các chế độ (π):")
print(hmm.startprob_)

print("\n📈 Tham số phát xạ Gaussian cho mỗi chế độ:")
for i in range(hmm.n_components):
    print(f"  ↪ Chế độ {i}:")
    print(f"     Trung bình: {hmm.means_[i]}")
    print(f"     Hiệp phương sai:\n{hmm.covars_[i]}")

# Huấn luyện Kalman Filter cho từng chế độ
kf_models = []
for mode in range(n_components):
    idx = predicted_modes == mode
    obs = true_position[idx]
    if len(obs) < 2:
        kf_models.append(None)
        continue
    kf = KalmanFilter(
        transition_matrices=[[1, 0], [0, 1]],
        observation_matrices=[[1, 0], [0, 1]],
        transition_covariance=1e-4 * np.eye(2),
        observation_covariance=np.cov(obs.T),
        initial_state_mean=obs[0],
        initial_state_covariance=np.eye(2)
    )
    kf = kf.em(obs, n_iter=10)
    kf_models.append(kf)

# Dự đoán trạng thái liên tục theo từng chế độ
filtered_states = np.zeros_like(true_position)
for mode in range(n_components):
    kf = kf_models[mode]
    idx = predicted_modes == mode
    if kf and np.sum(idx) > 1:
        obs = true_position[idx]
        state_means, _ = kf.filter(obs)
        filtered_states[idx] = state_means
    else:
        filtered_states[idx] = true_position[idx]  # fallback

# --- ĐÁNH GIÁ MÔ HÌNH ---

# 1. Sai số vị trí sau khi lọc (Kalman)
rmse = np.sqrt(mean_squared_error(true_position, filtered_states))
print(f"📏 RMSE (Vị trí thật vs vị trí đã lọc): {rmse:.4f}")

# 2. Độ chính xác chế độ nếu có nhãn thật
if true_modes is not None:
    # Vì HMM không biết nhãn, ta cần điều chỉnh mapping chế độ
    from scipy.stats import mode

    # Tìm mapping từ predicted_modes → true_modes (simple majority voting)
    mode_map = {}
    for k in range(n_components):
        mask = predicted_modes == k
        if np.any(mask):
           mapped_label = mode(true_modes[mask], keepdims=True).mode[0]
           mode_map[k] = mapped_label

    mapped_pred_modes = np.array([mode_map[m] for m in predicted_modes])
    acc = accuracy_score(true_modes, mapped_pred_modes)
    print(f"🎯 Độ chính xác phân loại chế độ (HMM vs nhãn thật): {acc*100:.2f}%")

for mode, kf in enumerate(kf_models):
    if kf is not None:
        print(f"Kalman Filter for Mode {mode}:")
        print(f"Transition matrix: \n{kf.transition_matrices}")
        print(f"Observation matrix: \n{kf.observation_matrices}")
    else:
        print(f"Mode {mode} does not have a Kalman filter.")

plt.figure(figsize=(10, 6))
plt.plot(true_position[:, 0], true_position[:, 1], color='gray', label='Thực tế', alpha=0.5)
for mode in range(n_components):
    idx = predicted_modes == mode
    plt.plot(filtered_states[idx, 0], filtered_states[idx, 1], '.', label=f'Lọc - Mode {mode}')
plt.xlabel("X Position")
plt.ylabel("Y Position")
plt.title("SLDS: Đường đi sau lọc Kalman theo chế độ")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()