# -*- coding: utf-8 -*-
"""TH2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OxE0vqfeymav1ytyiXD2waYSoXKcG_Bk
"""

import pandas as pd
import numpy as np
from hmmlearn.hmm import GaussianHMM
from pykalman import KalmanFilter
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error, accuracy_score

# Äá»c dá»¯ liá»‡u
df = pd.read_csv("slds_data.csv")

# Dá»¯ liá»‡u váº­n tá»‘c dÃ¹ng cho HMM
velocity_data = df[['VX', 'VY']].values
true_position = df[['X_Position', 'Y_Position']].values
true_modes = df['Mode'].values if 'Mode' in df.columns else None

# Huáº¥n luyá»‡n HMM Ä‘á»ƒ tÃ¬m cháº¿ Ä‘á»™ rá»i ráº¡c
n_components = 2
hmm = GaussianHMM(n_components=n_components, covariance_type="full", n_iter=100, random_state=42)
hmm.fit(velocity_data)
predicted_modes = hmm.predict(velocity_data)

print("ğŸ” Ma tráº­n chuyá»ƒn tráº¡ng thÃ¡i giá»¯a cÃ¡c cháº¿ Ä‘á»™ (A):")
print(hmm.transmat_)

print("\nğŸ¯ XÃ¡c suáº¥t ban Ä‘áº§u cá»§a cÃ¡c cháº¿ Ä‘á»™ (Ï€):")
print(hmm.startprob_)

print("\nğŸ“ˆ Tham sá»‘ phÃ¡t xáº¡ Gaussian cho má»—i cháº¿ Ä‘á»™:")
for i in range(hmm.n_components):
    print(f"  â†ª Cháº¿ Ä‘á»™ {i}:")
    print(f"     Trung bÃ¬nh: {hmm.means_[i]}")
    print(f"     Hiá»‡p phÆ°Æ¡ng sai:\n{hmm.covars_[i]}")

# Huáº¥n luyá»‡n Kalman Filter cho tá»«ng cháº¿ Ä‘á»™
kf_models = []
for mode in range(n_components):
    idx = predicted_modes == mode
    obs = true_position[idx]
    if len(obs) < 2:
        kf_models.append(None)
        continue
    kf = KalmanFilter(
        transition_matrices=[[1, 0], [0, 1]],
        observation_matrices=[[1, 0], [0, 1]],
        transition_covariance=1e-4 * np.eye(2),
        observation_covariance=np.cov(obs.T),
        initial_state_mean=obs[0],
        initial_state_covariance=np.eye(2)
    )
    kf = kf.em(obs, n_iter=10)
    kf_models.append(kf)

# Dá»± Ä‘oÃ¡n tráº¡ng thÃ¡i liÃªn tá»¥c theo tá»«ng cháº¿ Ä‘á»™
filtered_states = np.zeros_like(true_position)
for mode in range(n_components):
    kf = kf_models[mode]
    idx = predicted_modes == mode
    if kf and np.sum(idx) > 1:
        obs = true_position[idx]
        state_means, _ = kf.filter(obs)
        filtered_states[idx] = state_means
    else:
        filtered_states[idx] = true_position[idx]  # fallback

# --- ÄÃNH GIÃ MÃ” HÃŒNH ---

# 1. Sai sá»‘ vá»‹ trÃ­ sau khi lá»c (Kalman)
rmse = np.sqrt(mean_squared_error(true_position, filtered_states))
print(f"ğŸ“ RMSE (Vá»‹ trÃ­ tháº­t vs vá»‹ trÃ­ Ä‘Ã£ lá»c): {rmse:.4f}")

# 2. Äá»™ chÃ­nh xÃ¡c cháº¿ Ä‘á»™ náº¿u cÃ³ nhÃ£n tháº­t
if true_modes is not None:
    # VÃ¬ HMM khÃ´ng biáº¿t nhÃ£n, ta cáº§n Ä‘iá»u chá»‰nh mapping cháº¿ Ä‘á»™
    from scipy.stats import mode

    # TÃ¬m mapping tá»« predicted_modes â†’ true_modes (simple majority voting)
    mode_map = {}
    for k in range(n_components):
        mask = predicted_modes == k
        if np.any(mask):
           mapped_label = mode(true_modes[mask], keepdims=True).mode[0]
           mode_map[k] = mapped_label

    mapped_pred_modes = np.array([mode_map[m] for m in predicted_modes])
    acc = accuracy_score(true_modes, mapped_pred_modes)
    print(f"ğŸ¯ Äá»™ chÃ­nh xÃ¡c phÃ¢n loáº¡i cháº¿ Ä‘á»™ (HMM vs nhÃ£n tháº­t): {acc*100:.2f}%")

for mode, kf in enumerate(kf_models):
    if kf is not None:
        print(f"Kalman Filter for Mode {mode}:")
        print(f"Transition matrix: \n{kf.transition_matrices}")
        print(f"Observation matrix: \n{kf.observation_matrices}")
    else:
        print(f"Mode {mode} does not have a Kalman filter.")

plt.figure(figsize=(10, 6))
plt.plot(true_position[:, 0], true_position[:, 1], color='gray', label='Thá»±c táº¿', alpha=0.5)
for mode in range(n_components):
    idx = predicted_modes == mode
    plt.plot(filtered_states[idx, 0], filtered_states[idx, 1], '.', label=f'Lá»c - Mode {mode}')
plt.xlabel("X Position")
plt.ylabel("Y Position")
plt.title("SLDS: ÄÆ°á»ng Ä‘i sau lá»c Kalman theo cháº¿ Ä‘á»™")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()